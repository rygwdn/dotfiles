#!/bin/bash

# Set up ls
RUNNING_IN_WINDOWS=false
if [[ "$TERM" != "dumb" ]]; then
    if [[ "$TERM" == "cygwin" || "$CYGWIN" == "true" || -n "$MSYSTEM" ]]
    then
        alias ls='ls --color'
        export LS_COLORS=
        RUNNING_IN_WINDOWS=true
    elif which dircolors &> /dev/null
    then
        eval "$(dircolors -b)"
        alias ls='ls --color=auto'
    elif uname -s | grep -iq "Darwin"
    then
        alias ls='ls -G'
    fi
fi

alias rs="rsync -a --progress --stats"

alias cherokee="ssh linode -L 9090:localhost:9090 -t -C 'sudo killall cherokee-admin; sudo cherokee-admin -b'"
alias psa='ps aux | grep -v grep | grep -e "^USER" -e '


alias ll='ls -l'
alias la='ls -A'
alias l='ls -CF'
alias pp='popd'
alias pd='pushd'
alias ap='sudo aptitude'


alias ipy=ipython
alias nb="jupyter notebook"

function gv {
    if $RUNNING_IN_WINDOWS; then
        ( /dev/null gvim --fork=1 ) &>/dev/null
    else
        ( gvim -f "$@" & ) &>/tmp/vim_out
    fi
}

function _git_mod_files {
    local _path=$(git rev-parse --show-toplevel || pwd)
    local _files=
    # changed files
    #echo "1: $1"
    [[ -z "$1" ]] && _files="$(cd $_path ; git status --porcelain | sed 's/^ *[^ ]* *//' | sort -u)"
    #echo "f1: $_files"
    # files changed in HEAD
    [[ -z $_files ]] && _files="$(cd $_path; git diff-tree --no-commit-id --name-only -r ${1:-HEAD})"
    #echo "f2: $_files"
    _files=$(echo "$_files" | sed "s!^!$_path/!" | grep -v '/images/' | while read line ; do file "$line" | grep -q '\btext\b' && echo $line ; done)
    #echo "f3: $_files"
    echo "$_files"
}

function gmod {
    g $(_git_mod_files "$@" | xargs echo)
}
function vmod {
    vim $(_git_mod_files "$@" | xargs echo)
}

alias gses="g --servername"
alias gn="gses"
alias gchanged="gmod"

function vcs()
{
    prog=`(
    while [ "$(pwd)" != "$HOME" ] && [ "$(pwd)" != '/' ]
    do
        [ -e .git ] && echo 'git' && break
        [ -e .bzr ] && echo 'bzr' && break
        [ -e .hg ] && echo 'hg' && break
        cd ..
    done
    )`
    if [[ -n $prog ]]; then
        $prog "$@"
    else
        svn "$@"
    fi
}
__define_git_completion () {
    eval "
    _git_$2_shortcut () {
        COMP_LINE=\"git $2\${COMP_LINE#$1}\"
        let COMP_POINT+=$((4+${#2}-${#1}))
        COMP_WORDS=(git $2 \"\${COMP_WORDS[@]:1}\")
        let COMP_CWORD+=1

        local cur words cword prev
        _get_comp_words_by_ref -n =: cur words cword prev
        _git_$2
    }
    "
}

__git_shortcut () {
    type _git_$2_shortcut &>/dev/null || __define_git_completion $1 $2
    alias $1="git $2 $3"
    complete -o default -o nospace -F _git_$2_shortcut $1

    if hash git.exe &>/dev/null
    then
        alias ${1}e="gite $2 $3"
        complete -o default -o nospace -F _git_$2_shortcut ${1}e
    fi
}

__git_shortcut ci commit
__git_shortcut cif commit --amend --no-edit
__git_shortcut co checkout
__git_shortcut a add
__git_shortcut lg lg
__git_shortcut log log
__git_shortcut add add
__git_shortcut addp add --patch
__git_shortcut addi add -i
__git_shortcut gd diff
__git_shortcut gdc diff --cached
__git_shortcut br branch
__git_shortcut show show
__git_shortcut rb rebase
__git_shortcut rbi rbi
__git_shortcut rbis rbis

function gite {
    if hash git.exe &>/dev/null
    then
        git.exe "$@"
    else
        git "$@"
    fi
}

function gfu {
    upstream=$(gite config --list | grep -q '^remote\.origin\.' && echo 'origin' || echo 'upstream')
    [[ "$(gite config credential.helper)" == "lastpass" ]] && lpass sync
    gite fetch --prune --tags ${upstream} "$@"
}

function po {
    gite push origin "$@"
}

alias pof='po --force-with-lease'


alias gph='po --set-upstream HEAD'


alias stf='git st | fpp'

alias gl='lg -n-1 --all'
alias gk='gitk --all'
alias wip='git wip'
alias unwip='git unwip'

function st {
  summary=$(git log -1 --pretty=%s)
  echo "${summary}" | grep -q '^WIP: ' && echo "On a WIP commit: ${summary}"
  git st
}


function cor {
    br=$(recent_branches | fzf --no-sort --reverse)
    [[ ${SHELL##*/} == zsh ]] && print -s git checkout $br
    [[ -n $br ]] && git checkout $br
}

# fh - repeat history
fh() {
  print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed 's/ *[0-9]* *//')
}

which hub &>/dev/null && alias git=hub

# annoyances
alias c='cd'
alias d='cd'
alias dpgk='dpkg'


alias ..='cd ..'
alias ...='cd ../..'


# better gnome open command
function o()
{
    # special case
    op_prg=`for op in gnome-open open cygstart start explorer.exe
    do
        which $op &>/dev/null && echo $op && break
    done | tail -n 1`
    which reattach-to-user-namespace &>/dev/null && attach_prg=reattach-to-user-namespace

    for file in "$@"
    do
        if [[ "$op_prg" = "explorer.exe" ]] && $CYGWIN; then
            $op_prg "`cygpath -w "$file"`"
        else
            file=`echo "$file" | sed 's/\/$//'`
            $attach_prg $op_prg "$file"
        fi
    done
}

complete -F _aptitude -o default ap

alias e='ember'
alias vssh='vagrant ssh'
alias dc='docker-compose'
alias dm='docker-machine'
alias gu='gitup commit'
alias rg='rg -S'
alias ag='hash rg &>/dev/null && echo "Please consider using rg.." 1>&2; ag'

function docker-clean() {
    # clean up containers and their volumes
    docker rm -v $(docker ps -a -q -f status=exited)
    # clean up unused images
    docker rmi $(docker images -f "dangling=true" -q)
}

alias prr="pr release"

function pr {
  remote="$(git config --get remote.origin.url)"
  dest="${1}"
  upstream="$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' | sed -nr 's|^origin/(.*)$|\1|p')"

  if [[ -z "${upstream}" ]]
  then
    echo 'unable to find upstream'
    return 1
  fi

  if echo "$remote" | grep -q 'bitbucket.org'
  then
    path=$(echo "${remote}" | sed -nr 's|.*[/:]([^/]*/[^/]*)(\.git)?$|\1|p')
    dest_param=$([[ -n "${dest}" ]] && echo "&dest=${dest}")
    url="https://bitbucket.org/${path}/pull-requests/new?source=${upstream}&t=1${dest_param}"
    echo "$url"
    [[ -n ${BROWSER} ]] && "${BROWSER}" "${url}"
  else
    echo "Can't handle URL ${remote} yet.."
    return 1
  fi
}

function ds {
    [[ -z "$@" ]] && 1='.*'
    services="$(
        docker inspect \
            -f '{{.Id}} {{range $k, $v := .Config.Labels}}{{ if eq $k "com.docker.compose.service"}}{{$v}}{{end}}{{end}}' \
            $(docker-compose ps -q)
        )"
    container=$(echo "$services" | grep -m1 " $1$" | awk '{ print $1 }')
    if [[ -z $container ]]; then
        echo "Unable to find container, possible options:"
        echo "$services" | awk '{print $2}'
        return 1
    fi
    shift
    [[ -z "$@" ]] && 1=bash
    docker exec $([[ -t 0 ]] && echo "-it") $container env TERM=$TERM LANG=$LANG "$@"
}

function h() {
    hist=$([ -n "$ZSH_NAME" ] && echo "fc -l 1" || echo "history")
    echo "$1"
    if [[ -z "$1" ]]
    then
        cmd=$(eval $hist | fzf +s --tac)
        if [ -n "$ZSH_NAME" ]; then
            print -z $(echo "$cmd" | sed 's/^ *[0-9][0-9]* *//')
        else
            echo "$cmd"
        fi
    else
        eval $hist | grep "$@"
    fi
}

function dsysdig {
    docker run -it --rm --privileged \
        -v /var/run/docker.sock:/host/var/run/docker.sock \
        -v /dev:/host/dev \
        -v /proc:/host/proc:ro \
        -v /boot:/host/boot:ro \
        -v /lib/modules:/host/lib/modules:ro \
        -v /usr:/host/usr:ro sysdig/sysdig csysdig -pc "$@"
}

function skim {
    open -a Skim "$@"
}

function tname {
    # "tname <some name>" sets the tmux pane title and disallows zsh/vim/etc from changing it
    # "tname" re-allows the renaming of the window
    if [[ -n $1 ]]; then
        tmux rename-window "$*"
        tmux set-window-option allow-rename off
    else
        tmux rename-window zsh
        tmux set-window-option allow-rename on
    fi
}

[ -e ~/.bash_aliases_local ] && . ~/.bash_aliases_local
