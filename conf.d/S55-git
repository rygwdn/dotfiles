#!/usr/bin/env zsh

autoload colors
colors

__ZSH_STAT=stat
__ZSH_READLINK=readlink
which gstat &> /dev/null && __ZSH_STAT=gstat
which greadlink &> /dev/null && __ZSH_READLINK=greadlink

# ----------------------------------------------------------------------
# The following implements a caching mechanism for git information.
# The RPROMPT executes get_git_bprompt_info() and include the output...
#
#   setopt prompt_subst
#   RPROMPT="$(get_git_prompt_info)"
#
__ZSH_GIT_DIR=
__ZSH_GIT_BRANCH=
__ZSH_GIT_STATE=
__ZSH_TICGIT_STATE=
__ZSH_GIT_TS=0
__ZSH_GIT_VARS_INVALID=1

# get the name of the branch we are on
parse_git_branch() {
        git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1) -- /'
}

# http://blog.madism.org/index.php/2008/05/07/173-git-prompt
new_parse_git_branch() {
    force=$1

    psvar=()
    git_dir=$(git rev-parse --git-dir 2> /dev/null)
    if [[ -z "$git_dir" ]] ; then
            __ZSH_GIT_DIR=
            return
    fi

    new_stamp=$($__ZSH_STAT --printf='%Y' "$git_dir/HEAD")
    [[ "$force" == "0" && "$__ZSH_GIT_TS" == "$new_stamp" ]] && return

    # rewritten by Thomas Ritz <thomas(at)galaxy-ritz(dot)de>
    __ZSH_GIT_STATE=
    if [[ -d "$git_dir/rebase-apply" ]] ; then
            if [[ -f "$git_dir/rebase-apply/rebasing" ]] ; then
                    __ZSH_GIT_STATE="rebase"
            elif [[ -f "$git_dir/rebase-apply/applying" ]] ; then
                    __ZSH_GIT_STATE="am"
            else
                    __ZSH_GIT_STATE="am/rebase"
            fi
            branch="$(git symbolic-ref HEAD 2>/dev/null)"
    elif [[ -f "$git_dir/rebase-merge/interactive" ]] ; then
            __ZSH_GIT_STATE="rebase -i"
            branch="$(cat "$git_dir/rebase-merge/head-name")"
    elif [[ -d "$git_dir/rebase-merge" ]] ; then
            __ZSH_GIT_STATE="rebase -m"
            branch="$(cat "$git_dir/rebase-merge/head-name")"
    elif [[ -f "$git_dir/MERGE_HEAD" ]] ; then
            __ZSH_GIT_STATE="merge"
            branch="$(git symbolic-ref HEAD 2>/dev/null)"
    else
            [[ -f "$git_dir/BISECT_LOG" ]] && __ZSH_GIT_STATE="bisect"
            branch="$(git symbolic-ref HEAD 2>/dev/null)" || \
            branch="$(git describe --exact-match HEAD 2>/dev/null)" || \
            branch="$(cut -c1-7 "$git_dir/HEAD")..."
    fi

    __ZSH_TICGIT_STATE=
    if [[ -e "${git_dir}/refs/heads/ticgit" ]]; then
        __ZSH_TICGIT_STATE=`ti list | grep -c open`
    fi

    __ZSH_GIT_FULL_DIR=$($__ZSH_READLINK -f ${git_dir:h})
    __ZSH_GIT_DIR="${__ZSH_GIT_FULL_DIR/$HOME/~}"
    __ZSH_GIT_BRANCH="${branch#refs/heads/}"

    __ZSH_GIT_TS=$new_stamp
}


zsh_git_invalidate_vars() {
        __ZSH_GIT_VARS_INVALID=1
}
zsh_git_compute_vars() {
        new_parse_git_branch $1
        __ZSH_GIT_VARS_INVALID=0
}

# on each chdir update the cached git variable(s)
preexec_functions+='zsh_git_preexec_update_vars'
chpwd_functions+='zsh_git_chpwd_update_vars'

zsh_git_chpwd_update_vars() {
        zsh_git_compute_vars 1
}
zsh_git_preexec_update_vars() {
        case "$(history $HISTCMD)" in 
        *git*)  zsh_git_invalidate_vars
                ;;
        *ti*)  zsh_git_invalidate_vars # for ticgit
                ;;
        *)      [[ "$__ZSH_GIT_VARS_INVALID" == '0' ]] && return
                ;;
        esac
        zsh_git_compute_vars 1
}

get_git_prompt_info() {
        zsh_git_compute_vars $__ZSH_GIT_VARS_INVALID
        [[ -n "$__ZSH_GIT_DIR" ]] || return

        local state=""
        [[ `git status 2>&1 | wc -l` -gt 5 ]] && state="${PR_RED}+ ${PR_NO_COLOR}"
        local res="${PR_BLUE}[${state}${PR_GREEN}${__ZSH_GIT_BRANCH}${PR_BLUE}]"

        [[ -n "${__ZSH_GIT_STATE}" ]] && res="${PR_GREEN}(${__ZSH_GIT_STATE}) $res"
        [[ -n "${__ZSH_TICGIT_STATE}" ]] && res="${PR_BLUE}(${__ZSH_TICGIT_STATE}) $res"

        echo -n "${res}"
}

git-what-merged () {
        commit=${1:-HEAD}
        base=$(git merge-base "$commit^1" "$commit^2") 
        git log "$base..$commit^2"
}


# call it the first time
zsh_git_compute_vars

